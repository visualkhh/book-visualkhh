아토믹 코틀린 24장
====

# 리스트

```kotlin

/**
 * this 객체의 문자열 표현을
 * `rval` 문자열과 비교한다
 */
infix fun Any.eq(rval: String) {
  test(this, rval) {
    toString().trim() == rval.trimIndent()
  }
}

/**
 * this 객체가 `rval`과 같은지 검증한다
 */
infix fun <T> T.eq(rval: T) {
  test(this, rval) {
    this == rval
  }
}

/**
 * this != `rval` 인지 검증한다
 */
infix fun <T> T.neq(rval: T) {
  test(this, rval, checkEquals = false) {
    this != rval
  }
}

/**
 * 어떤 Double 값이 rval에 지정된 Double 값과 같은지 비교한다
 * 두 값의 차이가 작은 양숫값(0.0000001)보다 작으면 두 Double을 같다고 판정한다
 */
infix fun Double.eq(rval: Double) {
  test(this, rval) {
    abs(this - rval) < 0.0000001
  }
}

```
```kotlin
import atomictest.eq

fun main() {
  val ints = listOf(99, 3, 5, 7, 11, 13)
  ints eq "[99, 3, 5, 7, 11, 13]"   // [1]

  // List의 각 원소에 대해 이터레이션하기
  var result = ""
  for (i in ints) {                 // [2]
    result += "$i "
  }
  result eq "99 3 5 7 11 13"

  // List 원소를 '인덱싱'하기
  ints[4] eq 11                     // [3]
}

```


```kotlin
import atomictest.*

fun main() {
  val ints = listOf(1, 2, 3)
  capture {
    ints[3]
  } contains
    listOf("ArrayIndexOutOfBoundsException")
}

```


```kotlin
import atomictest.eq

fun main() {
  val doubles =
    listOf(1.1, 2.2, 3.3, 4.4)
  doubles.sum() eq 11.0

  val strings = listOf("Twas", "Brillig",
    "And", "Slithy", "Toves")
  strings eq listOf("Twas", "Brillig",
    "And", "Slithy", "Toves")
  strings.sorted() eq listOf("And",
    "Brillig", "Slithy", "Toves", "Twas")
  strings.reversed() eq listOf("Toves",
    "Slithy", "And", "Brillig", "Twas")
  strings.first() eq "Twas"
  strings.takeLast(2) eq
    listOf("Slithy", "Toves")
}

```

```kotlin
import atomictest.eq

fun main() {
  // 타입을 추론한다
  val numbers = listOf(1, 2, 3)
  val strings =
    listOf("one", "two", "three")
  // 똑같은 코드지만 타입을 명시했다
  val numbers2: List<Int> = listOf(1, 2, 3)
  val strings2: List<String> =
    listOf("one", "two", "three")
  numbers eq numbers2
  strings eq strings2
}

```

```kotlin
package lists
import atomictest.eq

// 반환 타입을 추론한다
fun inferred(p: Char, q: Char) =
  listOf(p, q)

// 반환 타입을 명시한다
fun explicit(p: Char, q: Char): List<Char> =
  listOf(p, q)

fun main() {
  inferred('a', 'b') eq "[a, b]"
  explicit('y', 'z') eq "[y, z]"
}

```

```kotlin
// Lists/MutableList.kt
// (c)2021 Mindview LLC. See Copyright.txt for permissions.
import atomictest.eq

fun main() {
    val list = mutableListOf<Int>()

    list.add(1)
    list.addAll(listOf(2, 3))

    list += 4
    list += listOf(5, 6)

    list eq listOf(1, 2, 3, 4, 5, 6)
}

```

```kotlin
// Lists/MutListIsList.kt
// (c)2021 Mindview LLC. See Copyright.txt for permissions.
package lists
import atomictest.eq

fun getList(): List<Int> =
  mutableListOf(1, 2, 3)

fun main() {
  // getList()는 읽기 전용 List를 만든다
  val list = getList()
  // list.add(3) // Unresolved reference: add
  list eq listOf(1, 2, 3)
}

```

```kotlin
// Lists/MultipleListRefs.kt
// (c)2021 Mindview LLC. See Copyright.txt for permissions.
import atomictest.eq

fun main() {
  val first = mutableListOf(1)
  val second: List<Int> = first
  second eq listOf(1)
//  first.add(2)
    first += 2;
  // second도 first에 의해 변경된 내용을 보게 된다
  second eq listOf(1, 2)
}

```

```kotlin
import atomictest.eq

fun main() {
  var list = listOf('X') // 불변 리스트
  list += 'Y' // 가변 리스트처럼 보임
  list eq "[X, Y]"
}

```

```kotlin
// Lists/PlusAssignPuzzle.kt
// (c)2021 Mindview LLC. See Copyright.txt for permissions.
import atomictest.eq

fun main() {
    // 'val'/'var'에 가변 리스트를 대입하는 경우:
    val list1 = mutableListOf('A') // or 'var'
    list1 += 'A' // 다음 줄과 같다:
    list1.plusAssign('A')               // [1]

    // 'val'에 불변 리스트를 대입하는 경우:
    val list2 = listOf('B')
    // list2 += 'B' // 다음 줄과 같다:
    // list2 = list2 + 'B'              // [2]

    // 'var'에 불변 리스트를 대입하는 경우:
    var list3 = listOf('C')
    list3 += 'C' // 다음 줄과 같다:
    val newList = list3 + 'C'           // [3]
    list3 = newList                     // [4]

    list1 eq "[A, A, A]"
    list2 eq "[B]"
    list3 eq "[C, C, C]"
}

```